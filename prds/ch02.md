# PRD: Chapter 2 - "Getting Started with Claude Code"

**Status**: Draft
**Version**: 1.0
**Last Updated**: January 26, 2026

---

## 1. Overview

Chapter 2 introduces developers to Claude Code CLI as their primary tool for compound engineering workflows. This beginner-friendly chapter teaches installation, first conversation patterns, the tool ecosystem (file operations, code execution, search), and the foundational mental model of Explore-vs-Implement modes. By chapter end, readers understand when to reach for Claude Code vs Cursor vs ChatGPT, and can execute basic prompting patterns that mirror professional agent workflows.

---

## 2. Learning Objectives

After completing this chapter, readers will be able to:

1. **Install and initialize Claude Code CLI** on macOS, Linux, and Windows, verify installation, and understand the project context system (CLAUDE.md).

2. **Execute your first conversation** with Claude Code, understand the command structure, and recognize how agent mode differs from chat-based LLM interaction.

3. **Master the tool ecosystem**: understand what file operations (Read, Write, Edit, Glob, Grep), code execution (Bash), and observability tools are available, and when each is appropriate.

4. **Apply basic prompting patterns**: write specific, goal-oriented prompts that reference file paths, provide context through code snippets, and give clear success criteria.

5. **Choose the right tool** for the task: understand the trade-offs between Claude Code (CLI, full codebase access), Cursor (IDE-integrated, real-time), and ChatGPT (conversational, web-accessible), and when each excels.

6. **Apply Explore-vs-Implement mental model**: recognize when to use exploration mode (understanding patterns before coding) vs implementation mode (generating code with informed context), and measure the efficiency gains.

---

## 3. Source Articles

### Primary Sources
1. **cursor-agent-workflows.md**: Covers practical agent patterns including Plan Mode, context management, Rules, TDD patterns, and developer traits that maximize agent effectiveness.

2. **llm-usage-modes-explore-vs-implement.md**: Comprehensive guide to the two-mode mental model: Exploration (learning existing patterns) and Implementation (generating code). Includes real-world workflows and efficiency metrics.

3. **agent-capabilities-tools-and-eyes.md**: Documents the tools available to agents (MCPs, Cloud CLIs, code quality tools) and observability mechanisms ("eyes") that enable better decision-making.

### Supplementary Sources (Added from KB Analysis Jan 27, 2026)
4. **mcp-server-patterns.md** - Model Context Protocol server architecture for extending Claude Code
5. **claude-code-terminal-basics.md** - Terminal interaction patterns and common commands
6. **skills-system.md** - Custom skills and slash commands for workflow automation
7. **yolo-mode-patterns.md** - YOLO mode for unattended operations and when to use it safely

---

## 4. Detailed Outline

### 4.1 Introduction: Agent vs Chat (500 words)

**Subsections:**
- **What Claude Code Is**: Not ChatGPT in a terminal. It's an agent—a tool that reads your codebase, makes changes, runs commands, and reasons iteratively.
- **Agent Mindset**: Shift from "I'll ask it to write code" to "I'll ask it to solve a problem given this context."
- **Why This Matters for Compound Engineers**: Speed compounds. One agent reading your entire codebase and making informed changes beats 10 turns of manual prompting.

**Key Distinctions**:
| Aspect | ChatGPT | Cursor | Claude Code |
|--------|---------|--------|-------------|
| **Medium** | Web, chat | IDE sidebar | Terminal/CLI |
| **Context** | Conversation history | Visible files + search | Full codebase + rules |
| **Output** | Text/code blocks | Code edits in real-time | Files modified, commands run |
| **Best For** | Explaining, brainstorming | Quick edits, discovery | Complex workflows, automation |
| **Cost** | Token-based | Included in IDE | Token-based |

---

### 4.2 Installation and Setup (400 words)

**Subsections:**
- **System Requirements**: macOS 11+, Linux (Ubuntu 20+), Windows 10+ with WSL2 or native.
- **Installation via npm**: Step-by-step for `npm install -g @anthropic-ai/claude-code` (or native binary).
- **Verify Installation**: `claude --version`, `claude --help`.
- **Project Context (CLAUDE.md)**: What it is, why it matters, minimal starter template.

**Starter CLAUDE.md Template**:
```markdown
# Project Context

## Quick Start
- Language: TypeScript / Python / Rust
- Package manager: npm / pip / cargo
- Main entry: src/index.ts

## Key Commands
- Build: npm run build
- Test: npm test
- Lint: npm run lint

## Important Patterns
- See .cursor/rules/ for detailed guidelines
- Architecture: Component-based
```

**Installation Walkthrough**:
1. Verify Node.js: `node --version` (14+)
2. Install: `npm install -g @anthropic-ai/claude-code`
3. Verify: `claude --version`
4. Initialize project: `claude init` (creates starter CLAUDE.md)
5. First command: `claude ask "List the main files in src/"`

---

### 4.3 Your First Conversation: Hello World (700 words)

**Subsections:**
- **Starting a Conversation**: `claude ask "<prompt>"` vs `claude chat` (interactive mode).
- **How Claude Code Works**: Reads files, runs commands, iterates. Shows you what it's doing.
- **Understanding the Output**: File paths, command outputs, reasoning. Each action is visible.
- **Context Window**: What's included automatically (CLAUDE.md, git history), what you must provide.

**Guided Walkthrough: "Create a Simple CLI Tool"**

Step 1: Ask an exploration question
```bash
claude ask "Show me the current project structure. What files exist in src/?"
```

What Claude Code does:
- Reads CLAUDE.md to understand project
- Globs `src/**/*` to list files
- Returns structured output

Step 2: Ask for implementation with context
```bash
claude ask "Create a simple CLI tool that reads a CSV file and prints a summary.
Follow existing patterns in src/ for error handling and argument parsing."
```

What Claude Code does:
- Searches for existing CLI examples
- Understands error handling patterns
- Writes the tool
- Shows you each file it created/modified

Step 3: Iterate with feedback
```bash
claude ask "The CSV reader is good, but add support for filtering by column name.
Make sure it works with the test files in data/samples/"
```

Claude Code:
- Reads existing code (knows what it just wrote)
- Adds filtering feature
- Runs tests to verify
- Shows results

**Key Learning**: Each turn builds on previous context. You're not starting over; Claude Code maintains conversation history and understanding of what it changed.

---

### 4.4 The Tool Ecosystem: What Claude Code Can Do (1000 words)

**Subsections:**
- **File Operations**: Read, Write, Edit, Glob, Grep
- **Code Execution**: Bash, running tests and builds
- **Observability**: Console logs, network requests, execution output
- **When to Use Each Tool**

**The Seven Core Tools**:

#### 4.4.1 Read (Understand Existing Code)
**Purpose**: Fetch file contents to understand patterns, architecture, implementation.

**Example**:
```bash
claude ask "Read src/services/auth.ts and explain how JWT tokens are verified"
```

Claude Code reads the file, understands the implementation, explains it. Essential for Exploration mode.

**When to use**:
- Learning existing patterns
- Understanding file before editing
- Debugging issues

#### 4.4.2 Write (Create New Files)
**Purpose**: Create new files (tests, configuration, documentation).

**Example**:
```bash
claude ask "Create tests/payment.test.ts with comprehensive tests for payment processing"
```

Claude Code writes the entire file. Used when file doesn't exist.

**When to use**:
- New files (tests, configs, documentation)
- Complete rewrites (backup manually)

#### 4.4.3 Edit (Modify Existing Files)
**Purpose**: Surgical changes to existing code. Replaces specific text blocks.

**Example**:
```bash
claude ask "In src/api/handler.ts, add rate limiting middleware to the POST /users endpoint"
```

Claude Code finds the endpoint, adds the middleware, shows the change. Safer than Write for existing files.

**When to use**:
- Modifying existing code
- Small, targeted changes
- Preserving surrounding context

#### 4.4.4 Glob (Find Files by Pattern)
**Purpose**: Discover files matching patterns. Agent-friendly alternative to `find`.

**Example**:
```bash
claude ask "Find all test files (*.test.ts) in the src/ directory"
```

Claude Code returns structured list. Agents use this to search before reading.

**When to use**:
- Finding files by extension
- Pattern matching
- Before Read operations

#### 4.4.5 Grep (Search File Contents)
**Purpose**: Full-text regex search. Find code patterns, strings, identifiers.

**Example**:
```bash
claude ask "Search for all calls to authenticateUser() in the codebase"
```

Claude Code returns matching lines with file paths and line numbers. Essential for understanding call sites.

**When to use**:
- Finding function calls
- Searching for patterns
- Understanding code relationships

#### 4.4.6 Bash (Execute Commands)
**Purpose**: Run any CLI command. Build, test, lint, deploy, manage infrastructure.

**Example**:
```bash
claude ask "Run npm test to verify the payment tests pass"
```

Claude Code executes, captures output, reasons over results. Can iterate based on failures.

**When to use**:
- Running tests
- Building code
- Running linters
- Infrastructure operations

#### 4.4.7 Console Output & Observability
**Purpose**: See what ran, what failed, what succeeded. Agent's primary feedback loop.

**Example**: Agent runs tests, sees failure, understands failure reason, proposes fix.

```
$ npm test

FAIL tests/payment.test.ts
  ✓ should process valid payment
  ✗ should handle failed payment
    Expected: { success: false, error: "Card declined" }
    Received: { success: true }

Agent sees this, understands the problem, proposes fix.
```

**When to use**:
- After every command (automatic)
- To verify changes work
- To understand failures

---

### 4.5 Basic Prompting Patterns (800 words)

**Subsections:**
- **Specificity Matters**: How to write prompts that produce correct code first try.
- **Providing Context**: When to include file paths, code snippets, patterns.
- **Verifiable Goals**: How tests, linters, and success criteria guide agents.

#### 4.5.1 Pattern 1: Question + Context + Goal

**Poor Prompt**:
```
"Add authentication to the API"
```

**Better Prompt**:
```
"Add JWT authentication to the POST /users endpoint in src/api/users.ts

Context:
- Authentication service exists at src/services/auth.ts
- Use the existing authenticateUser() function
- Return error format: { success: false, error: { code, message } }
- Reference src/api/posts.ts for the middleware pattern

Success criteria:
- Unauthenticated requests return 401
- Valid tokens return user data
- Tests in tests/auth.test.ts pass"
```

**Why it works**: Claude Code understands the exact expectation, knows where patterns exist, knows success metrics.

#### 4.5.2 Pattern 2: Reference Existing Code

**Before**:
```
"Add a date utility function"
```

**After**:
```
"Add a date utility function to src/utils/date.ts

Follow the pattern in src/utils/string.ts:
- Export both function and JSDoc comments
- Use TypeScript generics where appropriate
- Include unit tests inline in tests/

Need:
- parseISO(str: string): Date | null
- formatDate(date: Date, format: string): string
- isValidDate(val: unknown): val is Date"
```

**Why it works**: Agent sees the pattern, knows the style, knows what to implement.

#### 4.5.3 Pattern 3: Exploration Before Implementation

**Anti-pattern** (mixing modes):
```
"Add a new payment provider. Make it work with Stripe and PayPal."
```

**Better** (separation):
```
Step 1 (Explore):
"How is payment processing structured in this codebase? Show me PaymentProvider interface and one implementation."

Step 2 (Implement):
"Create StripeProvider implementing the PaymentProvider interface (from previous response).

Follow the pattern from PayPalProvider:
- [paste key methods here]
- Use config from src/config/stripe.ts
- Add tests following tests/providers/paypal.test.ts pattern"
```

**Why it works**: Exploration builds understanding. Implementation uses that understanding to generate correct code first try.

#### 4.5.4 Pattern 4: Use Tests as Specification

**Bad**:
```
"Add email validation"
```

**Good**:
```
"Write tests for email validation in tests/validation.test.ts

Scenarios:
- Valid emails: user@example.com, john.doe+test@company.co.uk
- Invalid: missing @, empty string, spaces
- Edge cases: international domains, subdomains

Then implement src/utils/validation.ts:validateEmail() to pass all tests"
```

**Why it works**: Tests are concrete specifications. Agent generates code to pass tests, not to match vague descriptions.

---

### 4.6 Claude Code vs Cursor vs ChatGPT (600 words)

**Subsections:**
- **When to Use Each**: Decision tree and use cases.
- **Trade-offs**: Speed vs context vs discoverability.

**Comparison Table**:

| Dimension | Claude Code | Cursor | ChatGPT |
|-----------|------------|--------|---------|
| **Best for** | Complex workflows, multi-file, automation | Quick edits, discovery, exploratory | Explaining concepts, brainstorming |
| **Codebase context** | Full repo via CLAUDE.md + tools | Open files + Cmd+L | Paste-based, limited |
| **Speed** | ~30s per turn (read/execute/reason) | <1s (inline suggestions) | ~5s (API) |
| **IDE Integration** | CLI/VS Code extension | Native in Cursor | Web/ChatGPT for VS Code |
| **Cost** | Tokens (Claude 3.5 Sonnet) | Included | $20/mo or pay-as-you-go |
| **Collaboration** | Branch + PR | Can share snippets | Easy to share links |
| **Production** | Yes (fully automated workflows) | Partial (editor-bound) | Risky (slow iteration) |
| **Parallel Execution** | Via git worktrees, cloud agents | Limited (single instance) | Not applicable |

**Decision Tree**:

```
Is this a quick code question?
├─ YES: ChatGPT or Cursor
└─ NO: Is this task contained in one or two files?
    ├─ YES: Cursor (faster inline editing)
    └─ NO: Is this production code with full testing?
        ├─ YES: Claude Code (full context, automated testing)
        └─ NO: Depends on your IDE preference
```

**Use Claude Code When**:
1. Task spans 3+ files
2. Requires running tests/builds to verify
3. You need git integration (branching, commits, PRs)
4. You want to run complex searches (Grep, Glob)
5. You're building automation (tools, scripts, workflows)
6. Full codebase context is essential

**Use Cursor When**:
1. You're actively coding (real-time inline suggestions)
2. Task is small and visible on screen
3. You want fastest iteration
4. Discovery mode (exploring what's possible)

**Use ChatGPT When**:
1. Explaining a concept
2. Brainstorming architecture
3. No codebase context needed
4. Quick reference questions

---

### 4.7 Explore Mode vs Implement Mode (900 words)

**Subsections:**
- **The Two-Mode Mental Model**: Why it matters, efficiency gains.
- **Exploration: Learning Before Building**.
- **Implementation: Building with Understanding**.
- **Real-World Workflow Example**.
- **Measuring Success**.

#### 4.7.1 Why Two Modes?

The core insight: **Without understanding, code generation is a lottery.**

**Without Exploration** (anti-pattern):
```
"Implement JWT authentication"
↓
Claude Code generates 200 lines
↓
"This doesn't match our patterns"
↓
"Refactor to match our existing auth"
↓
Claude Code refactors (still wrong)
↓
*3-4 more iterations*
↓
Result: 30 minutes, 800+ lines generated, frustration
```

**With Exploration** (better):
```
"How do we currently handle authentication?"
↓
Claude Code reads auth.ts, explains pattern
↓
"Implement JWT following that pattern"
↓
Claude Code generates correct code on first try
↓
Result: 7 minutes, 200 lines, working code
```

**Savings**: 23 minutes, 75% fewer lines generated, first-try correctness.

#### 4.7.2 Exploration Mode: Learn First

**Goal**: Build mental models before writing code.

**Key Exploration Questions**:
1. "How is [feature] currently implemented?"
2. "What patterns should I follow?"
3. "What are common pitfalls?"
4. "Show me an example."

**Example Workflow**:

```bash
# Question 1: Understanding existing patterns
claude ask "How does error handling work in this codebase?
Show me examples from 3 different files."

# Claude Code:
# - Greps for error handling patterns
# - Shows Result<T, E> pattern
# - Shows try-catch patterns
# - Shows custom Error classes
# - You understand the patterns

# Question 2: Specific pattern question
claude ask "Should I use Result<T, E> or throw exceptions for the new payment service?"

# Claude Code:
# - Analyzes codebase
# - Shows you chose Result<T, E> elsewhere
# - Explains reasoning (type-safe, explicit errors)

# Now you UNDERSTAND. You're ready to implement.
```

**Time**: 5 minutes. Knowledge gained: Priceless.

#### 4.7.3 Implementation Mode: Build with Informed Context

**Goal**: Generate code that's correct on first try.

**Key Implementation Pattern**:

```bash
claude ask "Create PaymentService following these patterns from exploration:

Pattern reference:
- Use Result<T, E> error type
- Log all operations to AuditLog
- Include unit tests

Implementation details:
- Methods: processPayment(), refundPayment(), getStatus()
- Config from src/config/payments.ts
- Tests following tests/services/payment.test.ts pattern

Success criteria:
- All methods return Result<T, PaymentError>
- Tests in tests/services/payment.test.ts pass
- npm run lint passes"
```

**Why it works**: Every requirement is informed by exploration. Agent generates correct code.

**Time**: 2 minutes. Result: Correct, working code.

#### 4.7.4 Real-World Example: Adding Rate Limiting

**Scenario**: Add rate limiting to API endpoints.

**Without Exploration** (5 iterations):
```
1. "Add rate limiting"
   → Generated with wrong strategy
2. "Use the existing RateLimiter class"
   → Doesn't integrate with existing middleware
3. "Make it work with our middleware chain"
   → Wrong error format
4. "Use our standard error response"
   → Missing configuration
5. "Add configuration like other services"
   → Finally correct
```

**With Exploration** (1 iteration):

Exploration (5 min):
```bash
# Question 1
claude ask "Do we have existing rate limiting? Show me the implementation."
# Answer: RateLimiter in src/middleware/rateLimit.ts

# Question 2
claude ask "What endpoints currently use rate limiting?"
# Answer: /api/login, /api/signup. See POST /users endpoint for pattern.

# Question 3
claude ask "What's our error response format for rate limit exceeded?"
# Answer: { success: false, error: { code: 'RATE_LIMIT_EXCEEDED', ... } }

# Question 4
claude ask "What configuration keys should I use?"
# Answer: window: 60s, max: 100 requests, stored in config/rateLimit.ts
```

Implementation (2 min):
```bash
claude ask "Add rate limiting to POST /api/data endpoint.

Specification from exploration:
- Use RateLimiter from src/middleware/rateLimit.ts
- Apply as middleware before handler
- Configuration: window 60s, max 100 requests
- Error format: { success: false, error: { code: 'RATE_LIMIT_EXCEEDED', message: 'Too many requests' } }
- Reference: POST /users endpoint has the pattern

Success criteria:
- Endpoint returns 429 when limit exceeded
- Rate limit resets after window
- Tests in tests/api/data.test.ts pass"
```

**Result**: Correct rate limiting, first try. Total time: 7 minutes.

#### 4.7.5 When to Use Each Mode

**Use Exploration When**:
- Starting new feature
- Unfamiliar codebase
- Complex architecture
- Evaluating approaches
- Debugging unclear issues

**Use Implementation When**:
- You've completed exploration
- Clear mental model exists
- Repeating established patterns
- Following explicit examples

**Use Both When**:
- Complex features (explore architecture, implement)
- Refactoring (understand design, generate new code)
- Integration (explore both systems, bridge them)

---

### 4.8 Exercises: Try It Yourself (400 words)

**Subsections:**
- **Exercise 1: Exploration Practice** (15 min)
- **Exercise 2: Basic Prompting** (20 min)
- **Exercise 3: Explore + Implement Workflow** (30 min)

#### 4.8.1 Exercise 1: Exploration Practice (15 min)

**Goal**: Learn to ask good exploration questions.

**Setup**: Use any real project (or sample project provided).

**Task**:
1. Ask Claude Code: "What's the main entry point for this project?"
2. Ask: "How does error handling work? Show me 3 examples."
3. Ask: "What testing framework is used? Show me one test file."
4. Ask: "What are the top 3 architectural patterns I should follow?"
5. Write a summary of what you learned (2 paragraphs).

**Success Criteria**:
- You understand 3+ patterns
- You can name 2 design decisions
- You've read actual code, not just description

#### 4.8.2 Exercise 2: Basic Prompting (20 min)

**Goal**: Write better prompts using the patterns from section 4.5.

**Task**:
1. Write a vague prompt (anti-pattern). Example: "Add a utility function"
2. Rewrite it using the "Question + Context + Goal" pattern
3. Run the rewritten prompt against Claude Code
4. Note how the output is more precise
5. Compare iterations needed (likely: rewrite needed fewer iterations)

**Success Criteria**:
- Rewritten prompt is 3+ sentences
- Includes file path references
- Specifies success criteria
- Generated code required fewer revisions

#### 4.8.3 Exercise 3: Full Explore + Implement Workflow (30 min)

**Goal**: Experience the efficiency gain.

**Scenario**: "Add a new feature to the project."

**Part A: Exploration** (10 min)
1. Ask Claude Code 3-5 questions about existing patterns
2. Document the patterns you discover
3. Identify where your feature fits architecturally

**Part B: Implementation** (15 min)
1. Write a detailed implementation prompt based on exploration
2. Run the prompt
3. Verify the code works (run tests, lint)
4. Note how many iterations were needed (expect: 1-2)

**Part C: Reflection** (5 min)
1. How many iterations without exploration would this have taken?
2. What did exploration teach you?
3. How would you write this feature next time in a similar project?

**Success Criteria**:
- Feature works (tests pass, linter passes)
- Exploration took ~10 minutes
- Implementation took ~5 minutes
- Code matches existing patterns

---

## 5. Key Examples

### 5.1 Code Examples Included

1. **Starter CLAUDE.md template**: Minimal context file to get started
2. **Hello World CLI tool**: CSV reader with filter feature (builds over 3 turns)
3. **Email validation**: Complete test-first workflow example
4. **Rate limiting integration**: Full exploration + implementation workflow
5. **Error handling pattern**: Demonstrates Result<T, E> vs try-catch
6. **Test example**: Unit + integration test structure

### 5.2 Scenario Walkthroughs

1. **Installing and First Command**: Step-by-step with actual output
2. **Reading Error Messages**: How to debug "file not found", "tool not available"
3. **Iterating on Feedback**: When Claude Code misunderstands, how to redirect
4. **Performance Iteration**: Running slow code, interpreting profiler output, optimizing

---

## 6. Diagrams Needed

### 6.1 Tool Ecosystem Map (1 diagram)

**Description**: Visual showing the 7 core tools (Read, Write, Edit, Glob, Grep, Bash, Observability) with arrows showing how they interact. Read → Understand. Bash → Execute. Console → Observe. This creates the agent feedback loop.

```
┌──────────────────────────────────────────────┐
│         Claude Code Tool Ecosystem           │
├──────────────────────────────────────────────┤
│                                              │
│  ┌────────────────────┐                      │
│  │   Read / Glob      │ ← Understand Code    │
│  │   Grep             │                      │
│  └────────┬───────────┘                      │
│           │                                  │
│           ▼                                  │
│  ┌──────────────────────┐                    │
│  │     Agent           │                     │
│  │   (Reasoning)       │ ← Make Decisions    │
│  └────────┬────────────┘                     │
│           │                                  │
│           ▼                                  │
│  ┌──────────────────────┐                    │
│  │ Write / Edit        │ ← Modify Code      │
│  │ Bash (run commands) │                     │
│  └────────┬────────────┘                     │
│           │                                  │
│           ▼                                  │
│  ┌──────────────────────┐                    │
│  │   Observe           │ ← Verify Changes    │
│  │ (Test output,       │                     │
│  │  Console logs,      │                     │
│  │  Build results)     │                     │
│  └─────────────────────┘                     │
│           │                                  │
│           └──────────────────┐               │
│                              │ Feedback Loop │
│                              ▼               │
│                    (Back to Agent)           │
│                                              │
└──────────────────────────────────────────────┘
```

### 6.2 Claude Code vs Cursor vs ChatGPT (1 diagram)

**Description**: Three overlapping circles showing strengths of each tool. Claude Code: Full codebase, automation, testing. Cursor: Real-time, IDE-integrated, fast. ChatGPT: Conceptual, portable, knowledge base.

```
                Claude Code
                    │
         ┌──────────┼──────────┐
         │          │          │
    Full Context   Can Run     Automation
    Full Codebase  Tests &
    Deep Change    Commands
         │          │
         │    ┌─────┴─────┐
         │    │   Cursor  │
         │    │  ┌────────┤
    Can Edit │  │ Real-time
         in  │  │ IDE-integrated
         IDE │  │ Fast iteration
         │    │  │
         │    └──┼─────────────┐
         │       │             │
    Quick     ChatGPT         Easy
    Integration  │           Share
               Portable     Conceptual
               Knowledge    Browsable
```

### 6.3 Explore vs Implement Flow (1 diagram)

**Description**: Two paths showing the efficiency difference. Top path (no exploration) shows 5 iterations. Bottom path (with exploration) shows exploration phase + 1 iteration.

```
WITHOUT EXPLORATION:

Dev: "Add authentication"
  ↓
Claude: Generates code (no pattern knowledge)
  ↓
Dev: "This doesn't match our patterns"
  ↓
Claude: Refactors (still wrong)
  ↓ (repeat 3-4 more times)
Dev: "Finally correct"
  ↓
TIME: 30 minutes
ITERATIONS: 5-6


WITH EXPLORATION:

Dev: "How does auth currently work?"
  ↓
Claude: Reads code, explains pattern
  ↓
Dev: "Implement auth following that pattern"
  ↓
Claude: Generates correct code
  ↓
Dev: "Done, it works"
  ↓
TIME: 7 minutes
ITERATIONS: 1
```

---

## 7. Cross-References

**Internal Chapter Links**:
- Chapter 1 (Philosophy): Why compound engineers need agents
- Chapter 3 (Advanced Prompting): Builds on basic patterns from 4.5
- Chapter 4 (CLAUDE.md Patterns): Deep dive into CLAUDE.md system
- Chapter 5 (Git Workflows): How to combine Claude Code with git automation
- Chapter 6 (Testing & Quality): TDD patterns for agents
- Chapter 7 (Building Tools): Creating custom skills and MCPs
- Chapter 8 (Production Workflows): Scaling Claude Code to large teams

**External References**:
- Cursor Blog (agent best practices)
- Anthropic Claude Documentation
- Compound Systems Engineering Philosophy

---

## 8. Word Count Target

| Section | Estimated Words |
|---------|-----------------|
| 4.1 Introduction | 500 |
| 4.2 Installation | 400 |
| 4.3 First Conversation | 700 |
| 4.4 Tool Ecosystem | 1000 |
| 4.5 Prompting Patterns | 800 |
| 4.6 Tool Comparison | 600 |
| 4.7 Explore vs Implement | 900 |
| 4.8 Exercises | 400 |
| Sidebars & Examples | 500 |
| **Total Chapter** | **5,800 words** |

**Rationale**: Beginner-friendly length (15-20 minute read). Heavy on examples and walkthroughs. All patterns are immediately applicable.

---

## 9. Media & Assets

### Images to Create
1. Tool ecosystem diagram (6.1)
2. Tool comparison grid (6.2)
3. Explore vs Implement comparison (6.3)
4. Installation flow chart (4.2)
5. Prompt quality progression (4.5)
6. Sample Claude Code conversation screenshot

### Code Samples to Provide
- `starter-CLAUDE.md`
- `example-csv-cli-tool.ts`
- `email-validation-complete.ts` (with tests)
- `rate-limiting-exploration-notes.md`
- `sample-prompts-bad-vs-good.md`

### Interactive Elements
- Checklist: "Before your first Claude Code session"
- Decision tree: "Which tool should I use?"
- Quick reference: "The 7 tools at a glance"

---

## 10. Status & Next Steps

**Status**: Draft

**Review Checklist**:
- [ ] Align with book's beginner-level writing style
- [ ] Validate all examples run on real projects
- [ ] Confirm Learning Objectives are testable
- [ ] Exercise 3 is feasible in 30 minutes
- [ ] Cross-references align with other chapters
- [ ] Diagrams are clear and useful

**Open Questions**:
1. Should we include native binary installation (vs npm)?
2. How deep into CLAUDE.md patterns? (Deferred to Chapter 4?)
3. Include Cursor IDE extension install? (Out of scope for Claude Code chapter)
4. Real project or provided sample project for exercises?

**Follow-Up Tasks**:
- [ ] Create all diagrams and code samples
- [ ] Get feedback from 3 beta readers (non-technical, technical, agent-experienced)
- [ ] Refine exercises based on pilot testing
- [ ] Write instructor guide for exercises

---

## 11. Appendix: Efficiency Metrics from Source Material

From `llm-usage-modes-explore-vs-implement.md`:

**Benchmark Results**:
- **Iterations to correct code**: 3-5 without exploration → 1-2 with exploration (60% reduction)
- **Development time**: 30 min without → 12 min with (60% faster)
- **Pattern violations**: 40% without → 5% with (8x improvement)
- **Learning retention**: No learning without → Retained mental model with (compounding)

**Key Takeaway**: Exploration mode investment (5 min) pays off 23x in implementation.

---

## 12. Appendix: Tool Matrix Reference

| Tool | Purpose | Caution | Common Mistake |
|------|---------|---------|-----------------|
| **Read** | Understand code | Can be slow on large files | Reading everything; use Grep to target |
| **Write** | Create files | Overwrites; back up manually | Using on existing files; use Edit instead |
| **Edit** | Modify existing | Can break context; test after | Missing surrounding lines; provide context |
| **Glob** | Find files | Can return many results; use patterns | Using without limits; add `*.ts` not `*` |
| **Grep** | Search contents | Regex needs escaping | Over-broad patterns; test with small queries first |
| **Bash** | Execute commands | Can fail silently; always check output | Not providing context about project setup |
| **Observe** | See results | Requires reading output carefully | Ignoring errors; read console logs fully |
