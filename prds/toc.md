# Table of Contents

> Compound Engineering: Master AI-Assisted Development with Claude Code

---

## Part I: Foundations (Beginner)

### Chapter 1: The Compound Systems Engineer
- What is compound engineering?
- The shift from typing code to orchestrating systems
- Your new identity: meta-engineer
- The economics of AI-assisted development
- **Source**: `my-doctrine.md`, `the-meta-engineer-identity.md`

### Chapter 2: Getting Started with Claude Code
- Installing Claude Code CLI
- Your first conversation
- Understanding the tool ecosystem
- Basic prompting patterns
- When to use Claude Code vs other tools
- **Source**: `cursor-agent-workflows.md`, `llm-usage-modes-explore-vs-implement.md`

### Chapter 3: Writing Your First CLAUDE.md
- What is CLAUDE.md and why it matters
- Anatomy of an effective CLAUDE.md
- Project-specific vs global instructions
- Common mistakes and how to avoid them
- **Source**: `writing-a-good-claude-md.md`, `hierarchical-rule-files-collocation.md`

---

## Part II: Core Techniques (Intermediate)

### Chapter 4: The 12-Factor Agent
- Principles for production-ready LLM agents
- Factor by factor breakdown with examples
- How each factor compounds over time
- Implementing factors in your projects
- **Source**: `12-factor-agents.md`, `agent-reliability-chasm.md`

### Chapter 5: The Verification Ladder
- Six levels of verification (types to formal proofs)
- Choosing the right level for each task
- Verification sandwich pattern
- Property-based testing for generated code
- **Source**: `verification-ladder.md`, `verification-sandwich-pattern.md`, `property-based-testing.md`

### Chapter 6: Quality Gates That Compound
- Gates as information filters
- Pre-commit hooks with Claude Code
- Automated code review in CI
- Building gates that teach the agent
- **Source**: `quality-gates-as-information-filters.md`, `claude-code-hooks-quality-gates.md`, `llm-code-review-ci.md`

---

## Part III: Advanced Patterns (Advanced)

### Chapter 7: Context Engineering Deep Dive
- Information theory for coding agents
- Progressive disclosure of context
- Hierarchical context patterns
- Managing context rot
- **Source**: `information-theory-coding-agents.md`, `progressive-disclosure-context.md`, `context-rot-auto-compacting.md`

### Chapter 8: The RALPH Loop
- Fresh context iteration pattern
- Building the task queue
- Memory through git and docs
- Multi-agent coordination
- Running agents overnight
- **Source**: `ralph-loop.md`, `24-7-development-strategy.md`, `learning-loops-encoding-problems-into-prevention.md`

### Chapter 9: Sub-Agent Architecture
- When to delegate to sub-agents
- Accuracy vs latency tradeoffs
- Agent swarm patterns
- Actor-critic adversarial coding
- Parallel agents for monorepos
- **Source**: `sub-agent-architecture.md`, `sub-agents-accuracy-vs-latency.md`, `agent-swarm-patterns-for-thoroughness.md`

---

## Part IV: Production Systems (Expert)

### Chapter 10: Building the Harness
- The four-layer harness architecture
- Building the factory, not just the product
- Infrastructure that compounds
- Telemetry-driven optimization
- **Source**: `building-the-harness.md`, `building-the-factory.md`, `closed-loop-telemetry-driven-optimization.md`

### Chapter 11: The Meta-Engineer Playbook
- Ad-hoc flows to deterministic scripts
- Prompts as the asset, not the code
- Skill atrophy: what to keep, what to let go
- The six waves of AI coding
- **Source**: `ad-hoc-flows-to-deterministic-scripts.md`, `prompts-are-the-asset-not-the-code.md`, `six-waves-of-ai-coding.md`

### Chapter 12: Case Studies & Reference
- Real production examples (~350K LOC)
- Troubleshooting guide
- Model switching strategy
- Cost optimization
- **Source**: Various project docs, `model-switching-strategy.md`, `ai-cost-protection-timeouts.md`

---

## Appendices

### Appendix A: CLAUDE.md Templates
- Starter template
- Full-stack project template
- Monorepo template
- API-focused template

### Appendix B: Prompt Library
- Common prompts for everyday tasks
- Debugging prompts
- Refactoring prompts
- Testing prompts

### Appendix C: Troubleshooting
- Common failures and fixes
- Context debugging framework
- Five-point error diagnostic

### Appendix D: Further Reading
- Thought leaders to follow
- Key blog posts and resources
- Community resources

---

## Word Count Targets

| Section | Target Words | Chapters |
|---------|--------------|----------|
| Part I: Foundations | 8,000-10,000 | 3 |
| Part II: Core Techniques | 10,000-12,000 | 3 |
| Part III: Advanced Patterns | 12,000-15,000 | 3 |
| Part IV: Production Systems | 10,000-12,000 | 3 |
| Appendices | 5,000-8,000 | 4 |
| **Total** | **45,000-57,000** | **16** |

---

## Diagram Requirements

Each chapter should have 2-4 diagrams. Priority diagrams:
- [ ] The compound engineering flywheel (Ch 1)
- [ ] Claude Code tool ecosystem (Ch 2)
- [ ] CLAUDE.md hierarchy (Ch 3)
- [ ] 12-factor agent overview (Ch 4)
- [ ] Verification ladder visual (Ch 5)
- [ ] Quality gate pipeline (Ch 6)
- [ ] Context window anatomy (Ch 7)
- [ ] RALPH loop cycle (Ch 8)
- [ ] Sub-agent architecture (Ch 9)
- [ ] Four-layer harness (Ch 10)
- [ ] Six waves timeline (Ch 11)
