# PRD: Chapter 3 - "Writing Your First CLAUDE.md"

## Overview

This chapter teaches readers how to craft effective CLAUDE.md files to onboard Claude (and other AI agents) with minimal, universally applicable guidance that maximizes code generation accuracy. The chapter progresses from fundamental principles (why CLAUDE.md matters, the stateless nature of LLMs) to practical implementation strategies, including the hierarchical context pattern for scaling to large codebases. Readers will learn that effective CLAUDE.md files are deliberately crafted (not auto-generated), carefully scoped (not monolithic), and organized hierarchically to match codebase structure. By the end, readers will be able to write their first CLAUDE.md and understand when and how to extend it hierarchically.

---

## Learning Objectives

By the end of this chapter, readers will be able to:

1. **Explain why CLAUDE.md is the preferred delivery mechanism** for project context, including the stateless nature of LLMs and the instruction-following degradation curve
2. **Apply the WHY-WHAT-HOW framework** to structure project documentation that covers purpose, technology stack, and workflow requirements
3. **Design effective CLAUDE.md files that stay under 300 lines** while covering universally applicable guidance only, using progressive disclosure to avoid context bloat
4. **Implement hierarchical CLAUDE.md files** at the root, domain, and subdomain levels to achieve 70-90% context reduction with 80-95% relevance
5. **Avoid common mistakes** including auto-generation, style guide duplication, monolithic growth, and stale context

---

## Source Articles

### Primary Sources
1. `writing-a-good-claude-md.md` - Foundational principles and best practices
2. `hierarchical-rule-files-collocation.md` - Collocation principle and scaling strategy
3. `hierarchical-context-patterns.md` - Deep-dive implementation guide with examples
4. `symlinked-agent-configs.md` - Multi-tool strategy for maintaining single source of truth

### Supplementary Sources (Added from KB Analysis Jan 27, 2026)
5. `prompt-caching-strategy.md` - How CLAUDE.md hierarchy integrates with prompt caching
6. `context-rot-auto-compacting.md` - Keeping CLAUDE.md files fresh and accurate
7. `semantic-naming-patterns.md` - How to name files and sections for discoverability
8. `few-shot-prompting-patterns.md` - Embedding examples in CLAUDE.md files

### Configuration & Customization Sources (Added from KB Scan Jan 28, 2026)
9. `claude-code-hooks-quality-gates.md` - Hooks customization (pre-commit, post-edit, post-write hooks as automated quality gates)
10. `mcp-server-project-context.md` - MCP server for dynamic project context (queryable knowledge beyond static files)
11. `yolo-mode-configuration.md` - YOLO mode configuration (--dangerously-skip-permissions for flow state)
12. `institutional-memory-learning-files.md` - Learning files pattern (*-learning.json for teaching LLMs past decisions)

---

## Detailed Outline

### 1. Introduction: The Silent Problem

**Section Goals**: Hook readers by showing the cost of context dilution

#### 1.1 The Context Problem
- Scenario: "You ask Claude to implement a Temporal workflow, but it generates API patterns instead"
- Root cause: Monolithic CLAUDE.md files (10,000+ lines) where only 7-8% is relevant
- Impact quantified: 3-5 iterations needed vs 1-2 with proper context

#### 1.2 Why This Chapter Matters
- CLAUDE.md affects every phase of AI-assisted development (planning, implementation, validation)
- Bad instructions cascade through entire codebase
- This chapter teaches leverage: one well-crafted file = thousands of better code generations

---

### 2. Understanding LLMs as Stateless Systems

**Section Goals**: Build mental model for why CLAUDE.md is necessary

#### 2.1 The Stateless Nature of Claude
- Zero codebase knowledge at session start
- Frozen weights at inference time (can't learn from current session)
- Only knowledge within provided tokens
- Implication: Every request must include essential context

#### 2.2 Why System Prompts Aren't Enough
- Anthropic's system prompt ~50 instructions
- Frontend models can reliably follow ~150-200 instructions total
- CLAUDE.md must minimize instruction count while maintaining necessary coverage
- Reference graph: instruction count vs. follow accuracy (from research paper)

#### 2.3 The Onboarding Function
- Table: WHAT (tech stack, structure) | WHY (purpose) | HOW (workflows)
- CLAUDE.md is the only reliable onboarding mechanism for project-specific context

---

### 3. The Instruction-Following Degradation Curve

**Section Goals**: Justify why less is more

#### 3.1 Research Findings
- Frontier models degrade linearly with instruction count
- Smaller models degrade exponentially
- Sweet spot: 150-200 instructions for reliable instruction-following

#### 3.2 The Token Budget for CLAUDE.md
- Calculate budget: 200 total instructions - 50 in system prompt = 150 available
- Frontier models (Claude Opus): Can stretch to ~200 with thinking
- Trade-off: More instructions = more hallucination risk

#### 3.3 Practical Implication
- Never use CLAUDE.md for style guide (expensive cognitive load, better solved with tooling)
- Example: "Use Biome for formatting" beats "Never use 4 spaces, always 2, except in JSX"
- Cost comparison: Auto-fixing linter vs. instruction-based style guide

---

### 4. Anatomy of an Effective CLAUDE.md

**Section Goals**: Provide concrete structure for readers to follow

#### 4.1 The Basic Structure
```
# Project Name

## Stack
[Language, frameworks, key dependencies - 5-10 lines]

## Structure
[Directory layout for monorepos - 10-20 lines]

## Commands
[Package manager commands, how to run tests - 10-15 lines]

## Conventions
[1-2 critical patterns only - 10-20 lines]

## Before Committing
[Verification steps - 5-10 lines]

## Documentation
[Links to task-specific docs - 5-10 lines]
```

#### 4.2 Length Guidelines
- Optimal: <300 lines
- Real-world examples: 60-100 lines at root
- Shorter is always better
- Green flag: <100 lines | Yellow flag: 100-300 lines | Red flag: >300 lines

#### 4.3 Checklist Before Shipping
- [ ] < 300 lines (ideally < 100)
- [ ] Every instruction is universally applicable
- [ ] No style/linting rules (use tooling instead)
- [ ] No inline code snippets (use file:line references)
- [ ] Task-specific docs are separate files
- [ ] Manually crafted, not auto-generated
- [ ] Covers WHAT, WHY, HOW

---

### 5. The Why-What-How Framework

**Section Goals**: Teach the mental model for CLAUDE.md content

#### 5.1 WHY: Purpose and Context
- Project's functional objectives
- Business domain (SaaS, CLI tool, library, etc.)
- What problems does this code solve?
- Example: "Social media content scheduler helping marketers save 5+ hours/week"

#### 5.2 WHAT: Technology Stack and Structure
- Language, frameworks, key dependencies
- Monorepo structure for complex projects
- Critical folders and their purposes
- Example: "Next.js 14 + TypeScript + FastAPI backend + Supabase database"

#### 5.3 HOW: Workflow Requirements
- Package manager and build commands
- How to verify changes work (testing, type checking, linting)
- When and how to commit
- Example: "Run `pnpm test` and `pnpm build` before committing"

---

### 6. Project-Specific vs Global Instructions

**Section Goals**: Teach readers when to include guidance in CLAUDE.md

#### 6.1 Universal Applicability Test
- Question: "Will every developer working on every file need to know this?"
- If YES: Include in CLAUDE.md
- If NO: Create task-specific documentation instead

#### 6.2 What Belongs in CLAUDE.md
- Package manager and build tool
- Monorepo structure and package purposes
- Global architecture patterns (factory functions, error handling approach)
- Verification procedures (before committing)

#### 6.3 What Doesn't Belong
- Style guides (use linters instead)
- Inline code snippets that rot (use file:line references)
- Database schema details
- API endpoint documentation
- Framework-specific patterns

#### 6.4 Progressive Disclosure Pattern
```
agent_docs/
  ├── building_the_project.md     # How to build
  ├── running_tests.md            # Test strategy
  ├── code_conventions.md         # Patterns
  ├── service_architecture.md     # Service layer
  ├── database_schema.md          # Database
  └── deployment.md               # Deploy procedure

CLAUDE.md references these:
"For database schema, see agent_docs/database_schema.md"
(Not embedded inline - use file references)
```

#### 6.5 Reference Format Best Practice
- Good: "See `services/billing/CLAUDE.md` for payment processing patterns"
- Bad: Embedded 500-line code snippets that become stale

---

### 7. Hierarchical Context: Scaling Beyond the Root File

**Section Goals**: Teach the architecture for growing codebases

#### 7.1 The Monolithic Problem Visualized
- Chart: Lines loaded vs relevance (10,247 lines total, only 800 relevant = 7.8%)
- Real example: 10,000-line root CLAUDE.md where Temporal patterns are at line 8,734
- Developer experience: 5-10 minutes to find patterns
- AI accuracy: 30-40% first-try correctness

#### 7.2 The Hierarchical Solution
```
/
├── CLAUDE.md (30-50 lines)
│   ├── Global architecture
│   ├── Core principles
│   └── Links to domain docs
│
├── packages/
│   ├── api/
│   │   ├── CLAUDE.md (200-300 lines)
│   │   │   ├── tRPC patterns
│   │   │   ├── Route handler conventions
│   │   │   └── Validation approach
│   │   │
│   │   └── src/routes/
│   │       ├── campaigns/
│   │       │   └── CLAUDE.md (50-100 lines)
│   │       │       ├── Campaign state machine
│   │       │       ├── Business constraints
│   │       │       └── Validation rules
│   │       │
│   │       └── users/
│   │           └── CLAUDE.md (50-80 lines)
│   │               └── Auth patterns
│   │
│   ├── database/
│   │   └── CLAUDE.md (250-350 lines)
│   │       ├── Schema patterns
│   │       ├── Migration approach
│   │       └── RLS policies
│   │
│   └── workflows/
│       └── CLAUDE.md (300-400 lines)
│           ├── Temporal patterns
│           ├── Determinism requirements
│           └── Activity patterns
```

#### 7.3 Loading Strategy
- When working on `packages/api/src/routes/campaigns/create.ts`:
  - Load: `/CLAUDE.md` (30 lines)
  - Load: `/packages/api/CLAUDE.md` (200 lines)
  - Load: `/packages/api/src/routes/campaigns/CLAUDE.md` (80 lines)
  - Total: 310 lines, 97% relevant
- Before: 10,247 lines loaded, 7.8% relevant
- Improvement: 96% context reduction, 19x better relevance

#### 7.4 File Size Guidelines by Level
| Level | Target | Min | Max |
|-------|--------|-----|-----|
| Root | 20-50 | 10 | 100 |
| Domain | 100-200 | 50 | 300 |
| Subdomain | 50-150 | 40 | 200 |

#### 7.5 When to Create Hierarchy Levels
- Root: Always
- Domain: When distinct patterns (API vs database vs workflows)
- Subdomain: When patterns diverge (user auth ≠ campaign workflows)
- Rule: Max 3-4 levels

---

### 8. Common Mistakes and How to Avoid Them

**Section Goals**: Teach by counterexample

#### 8.1 Mistake 1: Auto-Generating CLAUDE.md
- Problem: `/init` commands or auto-generation templates create generic, low-signal content
- Why it fails: Bad instructions cascade through planning and implementation phases
- Solution: Invest deliberate effort in crafting each line manually
- Red flags: "Use factory functions because it's a best practice" vs explaining why for *this* project

#### 8.2 Mistake 2: Using CLAUDE.md as a Style Guide
- Problem: "Use 2 spaces not 4", "CamelCase for variables" pollutes instruction budget
- Cost: Expensive cognitive load, poor instruction-following accuracy
- Solution: Use auto-fixing linters (Biome, ESLint)
- Example: One line "We use Biome for formatting" beats 50 lines of style rules

#### 8.3 Mistake 3: Monolithic Growth
- Problem: CLAUDE.md starts at 100 lines, grows to 5,000+ lines over time
- Symptom: Different team members working on different domains see irrelevant context
- Solution: Extract domain patterns into domain CLAUDE.md files
- Trigger to refactor: When root exceeds 100 lines, audit and move content

#### 8.4 Mistake 4: Inline Code Snippets
- Problem: 500-line code example embedded in CLAUDE.md becomes stale
- Why: Code changes, docs don't
- Solution: Use file:line references: "See `src/routes/users.ts:45-80` for pattern"
- Benefit: References stay current, code is single source of truth

#### 8.5 Mistake 5: Duplicating Content Across Levels
- Problem: Same pattern documented in root and domain files
- Example: Both files say "Use factory functions, never classes"
- Solution: Root has principle, domain specializes: "Routes use factory pattern (see root): export const..."
- Prevent: Code review checklist: "Are you duplicating parent content?"

#### 8.6 Mistake 6: Not Linking Between Levels
- Problem: LLM doesn't know `packages/api/src/routes/campaigns/CLAUDE.md` exists
- Solution: Always include "Related" section with links to parent, children, siblings
- Format:
  ```markdown
  ## Related
  - Parent: See root CLAUDE.md for global architecture
  - Siblings: packages/api/src/routes/users/CLAUDE.md
  - See: packages/database/CLAUDE.md for DTOs used here
  ```

#### 8.7 Mistake 7: Stale Context
- Problem: Code patterns change but CLAUDE.md doesn't
- Solution: Update CLAUDE.md in same PR as code changes
- Git hook: Alert when code in a directory changes but CLAUDE.md doesn't

---

### 9. Templates for Different Project Types

**Section Goals**: Provide starting templates readers can adapt

#### 9.1 Monorepo with Multiple Services (Next.js + FastAPI)
```markdown
# [Project Name]

## What

**Purpose**: [One sentence business goal]

**Tech Stack**:
- Frontend: Next.js 14 + TypeScript + React
- Backend: FastAPI (Python) in `/api`
- Database: Supabase (PostgreSQL)
- Real-time: Temporal (background jobs)

**Structure**:
- `/packages/web` - Next.js frontend
- `/packages/api` - FastAPI backend
- `/packages/database` - Database migrations
- `/packages/types` - Shared TypeScript types

## Why

We're building [business domain]. This structure separates concerns:
- Frontend handles [user-facing features]
- Backend handles [data processing, auth, business logic]
- Database layer ensures type safety across services

## How

**Setup**:
```bash
# Install dependencies
bun install

# Start services
bun dev          # Frontend + backend
bun db:migrate   # Database migrations
```

**Before Committing**:
```bash
bun test       # Run all tests
bun build      # Type check and build
```

## Conventions

**API Routes**: See `packages/api/CLAUDE.md` for patterns
**Database**: See `packages/database/CLAUDE.md` for migrations
**Frontend**: See `packages/web/CLAUDE.md` for React patterns

## Key Principles

1. **Type Safety**: TypeScript strict mode everywhere
2. **Result Types**: Return Result<T, E> from services, never throw
3. **Integration Tests**: Test actual behavior, not mocks
4. **Colocated Docs**: Each package has CLAUDE.md with domain patterns
```

#### 9.2 Single-Package API (tRPC + Prisma)
```markdown
# [Project Name] API

## What

TypeScript API using tRPC for type-safe RPC, Prisma for database access.

**Tech Stack**:
- tRPC v11 (type-safe API)
- Prisma ORM (database)
- Zod (validation)
- Next.js (server)

**Structure**:
- `src/routers/` - tRPC route handlers
- `src/server/` - Core server setup
- `src/db/` - Prisma client, migrations

## Why

tRPC gives us type safety across client-server boundary. Prisma keeps database layer type-safe. Zod validates all user input.

## How

**Development**:
```bash
npm run dev      # Start development server
npm run db:push  # Apply schema changes
npm test         # Run tests
```

**Before Committing**:
```bash
npm run test
npm run type-check
npm run build
```

## Conventions

See `src/routers/CLAUDE.md` for route handler patterns
See `src/db/CLAUDE.md` for database patterns
```

#### 9.3 Temporal Workflows Service
```markdown
# Temporal Workflows

## What

Temporal SDK (TypeScript) for long-running, reliable background jobs.

**Tech Stack**:
- Temporal SDK (@temporalio/workflow)
- Node.js worker execution
- TypeScript

**Structure**:
- `src/workflows/` - Workflow definitions (deterministic)
- `src/activities/` - Activity implementations (side effects)
- `src/worker.ts` - Worker that executes workflows

## Why

Temporal ensures long-running operations complete reliably, handle failures gracefully, and maintain audit trail of all executions.

## How

**Start worker**:
```bash
npm run worker
```

**Run test workflow**:
```bash
npm run test
```

## Conventions

See `src/workflows/CLAUDE.md` for determinism requirements
See `src/activities/CLAUDE.md` for activity patterns
```

---

### 10. Implementation Workshop

**Section Goals**: Teach readers to write their first CLAUDE.md

#### 10.1 Step-by-Step Process
1. **Identify your domain** (API? CLI? Database layer?)
2. **Write purpose** (Why does this project exist in 1-2 sentences?)
3. **List tech stack** (Languages, frameworks, key tools)
4. **Sketch structure** (Folder layout, package purposes)
5. **Document workflow** (How to develop, test, build)
6. **Add conventions** (1-2 universal patterns max)
7. **Review against checklist** (Section 4.3)

#### 10.2 Real-World Example Walk-Through
- Start with 200-line CLAUDE.md for hypothetical project
- Show how it could be organized hierarchically as project grows
- Compare: "When should we extract to domain files?"

#### 10.3 Common Questions
- Q: "Should I include database schema in CLAUDE.md?"
  - A: No. Link to `schema.prisma` instead, or create separate `database.md`
- Q: "What if my project is small (single file)?"
  - A: Still write CLAUDE.md. It helps future collaborators and LLMs.
- Q: "How often should I update CLAUDE.md?"
  - A: Every time code patterns change. Same PR as code changes.

---

### 11. Multi-Tool Strategy: Syncing Across Claude, Cursor, Aider

**Section Goals**: Teach sustainable pattern for teams using multiple tools

#### 11.1 The Multi-Tool Problem
- Claude Code reads CLAUDE.md
- Cursor reads .cursorrules
- Aider reads .aider/AGENTS.md
- Result: Duplicated rules, drift between tools

#### 11.2 Solution: Symlinked Master Rules File
```bash
# Create master rules file
touch RULES.md

# Link tools to master
ln -s RULES.md CLAUDE.md
ln -s RULES.md .cursorrules
ln -s RULES.md .aider/AGENTS.md

# All tools now read from single source
```

#### 11.3 Git Handling
- Symlinks work fine in git (both macOS/Linux)
- Windows developers: Use `git config core.symlinks true`
- CI/CD: Handles symlinks automatically

#### 11.4 Tool-Specific Extensions
```
RULES.md          # Shared rules (master)
CLAUDE.md         # Symlink to RULES.md
.cursorrules      # Symlink to RULES.md
.aider/
  ├── AGENTS.md   # Symlink to RULES.md
  └── extra.md    # Tool-specific extensions (optional)
```

---

### 11.5 Advanced Configuration: Hooks, MCP Servers, and YOLO Mode

**Section Goals**: Teach advanced CLAUDE.md customization for power users

#### 11.5.1 Claude Code Hooks as Quality Gates

Hooks automate verification on every tool call:

```json
// .claude/hooks/post-write.json
{
  "command": "npx eslint {file} --fix && tsc --noEmit",
  "description": "Lint and type check on every file write",
  "continueOnError": false
}
```

**Hook types**:
- **Pre-commit**: Run before any file modification
- **Post-edit**: Run after editing existing files (type checking)
- **Post-write**: Run after creating/overwriting files (linting, tests)

**Key insight**: Hooks replace manual verification loops. Instead of asking Claude to lint, hooks run automatically.

**Reference**: See `claude-code-hooks-quality-gates.md` for complete implementation patterns including:
- Chaining multiple checks (`lint && type-check && test`)
- Conditional hooks by file type (TypeScript vs JSON vs Markdown)
- Performance optimization with incremental checking
- Keyboard shortcut Ctrl+O for diagnosing failures

#### 11.5.2 MCP Servers for Dynamic Project Context

Static CLAUDE.md files have limits. MCP servers provide queryable, dynamic context:

```typescript
// MCP server resources
const resources = [
  "architecture-graph://auth",     // Dependency graph
  "pattern-examples://factory",    // Real code examples
  "recent-changes://last-week",    // Git history
  "test-coverage://modules",       // Coverage metrics
];
```

**When to use MCP vs CLAUDE.md**:
- **CLAUDE.md**: Principles, patterns, standards (rarely change)
- **MCP Server**: Current state, real examples, live metrics (change frequently)

**Reference**: See `mcp-server-project-context.md` for:
- MCP server implementation (TypeScript)
- Resource URI design patterns
- Integration with Claude Code configuration
- Performance: 87% context reduction by loading only relevant context

#### 11.5.3 YOLO Mode for Flow State

Permission prompts destroy flow state. YOLO mode eliminates interruptions:

```bash
# YOLO Mode alias
alias claude='ENABLE_BACKGROUND_TASKS=1 claude --dangerously-skip-permissions --allowedTools "*"'
```

**Safety with YOLO mode**:
- Git is your safety net (all changes are reversible)
- Quality gate hooks catch errors automatically
- Claude's built-in caution still applies
- You monitor output in real-time (can Ctrl+C if needed)

**Key insight**: Trust quality gates instead of permission prompts. Automated verification is more reliable than manual approval clicking.

**Reference**: See `yolo-mode-configuration.md` for:
- Safety hierarchy (Git + hooks + monitoring)
- Best practices (commit before large changes, watch output)
- Integration with 24/7 development patterns

#### 11.5.4 Learning Files for Institutional Memory

Prevent LLMs from re-proposing rejected ideas:

```json
// eslint-rules-learning.json
{
  "decisions": [
    {
      "id": "max-lines-per-function",
      "status": "rejected",
      "rationale": "Too opinionated, breaks valid long integration tests"
    }
  ]
}
```

**Learning file pattern**:
1. Track decisions (approved/rejected/deferred)
2. Include rationale and context
3. LLM reads file before generating suggestions
4. No more redundant suggestions

**Reference**: See `institutional-memory-learning-files.md` for:
- Schema definition for learning files
- Integration with automated scanners
- Benefits: 60% noise reduction in monthly scans

---

### 12. Integration with Other Patterns

**Section Goals**: Show how CLAUDE.md connects to broader system

#### 12.1 CLAUDE.md + Custom ESLint Rules
- CLAUDE.md documents pattern: "Always use factory functions"
- ESLint enforces: `no-classes: 'error'`
- Together: Humans read docs, tooling enforces

#### 12.2 CLAUDE.md + Prompt Caching
- Hierarchical CLAUDE.md files cache well (root rarely changes)
- Structure:
  ```typescript
  const cachedRoot = await readFile('CLAUDE.md');
  const cachedDomain = await readFile('packages/api/CLAUDE.md');
  const dynamicSubdomain = await readFile('packages/api/src/routes/campaigns/CLAUDE.md');

  // Use prompt caching for first two, not third
  ```

#### 12.3 CLAUDE.md + Test-Based Regression Patching
- Bug found: Campaign status validation missing
- Process:
  1. Write test that catches bug
  2. Fix code
  3. Update `packages/api/src/routes/campaigns/CLAUDE.md` to document pattern
  4. Future LLM sees pattern, never makes same mistake

---

### 13. Measuring Success

**Section Goals**: Give readers metrics to track if CLAUDE.md is working

#### 13.1 Context Relevance Metric
- Calculate: (Relevant lines loaded) / (Total lines loaded)
- Target: >80%
- Monolithic: 7-8% | Hierarchical: 80-95%

#### 13.2 First-Try Correctness
- % of LLM-generated code that works without iteration
- Monolithic: 30-40% | Hierarchical: 70-85%
- Track per domain

#### 13.3 Time to Find Patterns
- How long to locate relevant documentation?
- Monolithic: 5-10 minutes (search 10K lines)
- Hierarchical: <30 seconds (file in same directory as code)

#### 13.4 Developer Satisfaction
- Survey: "Can you easily find patterns for your domain?"
- Target: >80% answer "yes"

---

### 14. Case Study: Before and After Hierarchical Refactoring

**Section Goals**: Concrete example of transformation

#### 14.1 Before: Monolithic CLAUDE.md
- File: `/CLAUDE.md` (8,500 lines)
- Structure: Global + API + Database + Frontend + Workflows + 50 more sections
- Problem: 94% noise when working on any single domain

#### 14.2 After: Hierarchical Structure
- Root: 40 lines (architecture, principles, links)
- API domain: 200 lines (tRPC patterns)
- Database domain: 250 lines (migrations, RLS)
- Workflows domain: 300 lines (determinism, activities)
- API subdomain: 100 lines (campaign-specific rules)
- Total: Same information, better organized

#### 14.3 Impact
- Context loaded: 8,500 → 310 lines (96% reduction)
- Relevance: 6% → 97% (16x improvement)
- First-try correctness: 35% → 78%
- Time to find patterns: 8 minutes → 20 seconds

---

### 15. Conclusion and Next Steps

**Section Goals**: Wrap up and provide path forward

#### 15.1 Key Takeaways
1. CLAUDE.md is the preferred delivery mechanism for project context
2. Minimize instructions while maintaining necessary coverage
3. Use hierarchical structure to scale to large codebases
4. Avoid common mistakes (auto-generation, monolithic growth, style guides)
5. Treat CLAUDE.md as first-class code, not afterthought

#### 15.2 Getting Started
- Write your first CLAUDE.md today (even if 10 lines)
- Use template for your project type (Section 9)
- Follow the implementation workshop (Section 10)
- Measure using metrics in Section 13

#### 15.3 Next Chapter Preview
- Chapter 4: Advanced context management patterns (prompt caching, context rot, semantic naming)

---

## Key Examples

### Example 1: Minimal Effective CLAUDE.md (Next.js + FastAPI)
A 60-line CLAUDE.md that covers everything needed for both frontend and backend development without bloat.

### Example 2: Hierarchical Expansion
Show how a 100-line root file expanded to 5 domain files (40 + 200 + 250 + 300 + 100 lines) as project grew, maintaining <300 line limit per file.

### Example 3: Real Pattern Migration
Before: API route patterns documented in root (300 lines) → After: Extracted to `packages/api/src/routes/CLAUDE.md` (150 lines), reducing root by 50%.

### Example 4: Campaign Domain CLAUDE.md
Complete example showing how to document a specific domain with status workflow, business constraints, validation rules, and code examples.

### Example 5: Monolithic vs Hierarchical Loading
Side-by-side comparison: When implementing Temporal workflow, what context loads with monolithic vs hierarchical structure? Show the noise difference.

---

## Diagrams Needed

### Diagram 1: Context Dilution Problem
**Description**: Bar chart showing context loaded vs. context relevant for Temporal workflow task
- Monolithic: 10,247 lines loaded, 800 relevant (shown as thin slice)
- Hierarchical: 310 lines loaded, 300 relevant (nearly full bar)
- Highlights the 96% context reduction

### Diagram 2: Instruction-Following Degradation Curve
**Description**: Line graph showing instruction-following accuracy vs. number of instructions
- X-axis: Number of instructions (0-300)
- Y-axis: Accuracy (0-100%)
- Curve: Shows decline, frontier models linear, smaller models exponential
- Highlight: Sweet spot at 150-200 instructions

### Diagram 3: Hierarchical CLAUDE.md Structure
**Description**: Tree diagram showing hierarchy levels
```
/CLAUDE.md (Root - 40 lines)
  ├── packages/api/CLAUDE.md (Domain - 200 lines)
  │   ├── src/routes/users/CLAUDE.md (Subdomain - 80 lines)
  │   └── src/routes/campaigns/CLAUDE.md (Subdomain - 90 lines)
  ├── packages/database/CLAUDE.md (Domain - 250 lines)
  ├── packages/workflows/CLAUDE.md (Domain - 300 lines)
  │   ├── src/workflows/CLAUDE.md (Subdomain - 150 lines)
  │   └── src/activities/CLAUDE.md (Subdomain - 120 lines)
  └── packages/ui/CLAUDE.md (Domain - 280 lines)
```

### Diagram 4: File Size Guidelines
**Description**: Horizontal bar chart or gauge showing target ranges
- Root: 20-50 lines (green if <50, yellow if 50-100, red if >100)
- Domain: 100-200 lines (green if 100-250, yellow if 250-350, red if >350)
- Subdomain: 50-150 lines (green if 50-150, yellow if 150-200, red if >200)

### Diagram 5: Context Loading Strategy
**Description**: Flowchart showing how LLM loads context hierarchically
- File being edited: `packages/api/src/routes/campaigns/create.ts`
- Loading sequence:
  1. Find containing directory: `packages/api/src/routes/campaigns/`
  2. Load: `packages/api/src/routes/campaigns/CLAUDE.md`
  3. Walk up: `packages/api/src/routes/`
  4. Load: `packages/api/src/routes/CLAUDE.md` (if exists)
  5. Walk up: `packages/api/`
  6. Load: `packages/api/CLAUDE.md`
  7. Walk up: Root
  8. Load: `CLAUDE.md`

### Diagram 6: Before/After Case Study
**Description**: Split view showing monolithic vs hierarchical
- Left: 8,500-line single file with all domains mixed
- Right: 5 focused files (40 + 200 + 250 + 300 + 100)
- Arrows show extraction and reduction
- Metrics below each

### Diagram 7: Hooks Pipeline (Added Jan 28, 2026)
**Description**: Flow diagram showing how hooks trigger on file operations
- Trigger: File write event
- Pipeline: post-write.json -> lint -> type-check -> test
- Gate: Pass/Fail decision
- Output: Continue operation or surface error
- Show Ctrl+O diagnostic flow

### Diagram 8: Static vs Dynamic Context (Added Jan 28, 2026)
**Description**: Comparison showing when to use CLAUDE.md vs MCP servers
- Left side: CLAUDE.md (principles, patterns, standards)
- Right side: MCP Server (live metrics, real examples, current state)
- Middle: Decision flow based on change frequency
- Metrics: 87% context reduction with MCP

---

## Exercises

### Exercise 1: "Audit Your CLAUDE.md" (20-30 minutes)

**Task**: If you have a CLAUDE.md, apply the checklist from Section 4.3. If not, analyze a colleague's.

**Steps**:
1. Count total lines (target <300)
2. Identify instructions that aren't universally applicable
3. Find any style guide rules (should be tooling instead)
4. Check for inline code snippets older than 6 months
5. List what's missing (WHAT, WHY, or HOW)
6. Propose 3 improvements

**Output**: Written list of findings + one pull request with improvements

**Success Criteria**:
- Document identifies at least 1 non-universal instruction
- Proposes moving at least 1 style rule to tooling
- PR reduces file size or improves relevance

---

### Exercise 2: "Design Your Domain Hierarchy" (30-45 minutes)

**Task**: If your project is growing beyond 150 lines, design how to split into hierarchical structure.

**Steps**:
1. List all domains in your project (API, database, workflows, UI, etc.)
2. Estimate lines per domain in current CLAUDE.md
3. Create folder structure for domain CLAUDE.md files
4. Sketch content for each (30-second summary of what goes where)
5. Design linking strategy (how files reference each other)
6. Calculate: total lines before and after (should be same content, better organized)
7. Identify: which domain needs subdomain files?

**Output**: Folder structure diagram + sample links between levels

**Success Criteria**:
- Root <50 lines (just navigation + core principles)
- Each domain 100-300 lines
- Clear linking between hierarchy levels
- Same total content, better organized

---

### Exercise 3: "Write Your First Domain CLAUDE.md" (45-60 minutes)

**Task**: Extract patterns from one domain of your project into a domain-level CLAUDE.md.

**Steps**:
1. Pick a domain (API, database, workflows, frontend, CLI, etc.)
2. Audit existing code in that domain (scan 5-10 files)
3. Identify patterns (recurring structure, conventions, validation approaches)
4. Write domain CLAUDE.md covering:
   - Architecture (what this domain does)
   - Patterns (3-5 recurring patterns with code examples)
   - Anti-patterns (what NOT to do)
   - Testing approach
   - Related links (to parent root CLAUDE.md, to sibling domains)
5. Target: 150-250 lines
6. Get feedback: "If you were new to this domain, would this help you?"

**Output**: New CLAUDE.md file for your domain

**Success Criteria**:
- Covers 3+ distinct patterns with code examples
- Each pattern shown with "DO" and "DON'T" examples
- Links to root CLAUDE.md and sibling domains
- Team can understand domain patterns from this file alone
- 150-250 lines

---

## Cross-References

### Chapters This Builds On
- **Chapter 1: The Meta-Engineer Identity** - Why you need to think systematically about documentation
- **Chapter 2: Building the Harness** - CLAUDE.md is part of your development harness

### Chapters This Enables
- **Chapter 4: Advanced Context Management** - Prompt caching, context rot, semantic naming
- **Chapter 5: Prompt Caching Strategy** - How to structure hierarchical CLAUDE.md for caching efficiency
- **Chapter 6: Test-Based Regression Patching** - How to update CLAUDE.md when fixing bugs
- **Chapter 7: Custom ESLint Rules for Determinism** - Enforcing patterns documented in CLAUDE.md
- **Chapter 8: Hierarchical Context Patterns in Large Codebases** - Deep dive into scaling

### Related Patterns (in Knowledge Base)
- Institutional Memory Learning Files (why patterns exist)
- Prompt Caching Strategy (cache hierarchy efficiently)
- Custom ESLint Rules for Determinism (enforce documented patterns)
- Semantic Naming Patterns (make CLAUDE.md discoverable)
- Few-Shot Prompting with Project Examples (store examples in domain CLAUDE.md)

### Tools and Reference
- Claude Code Documentation (how Claude loads CLAUDE.md)
- Cursor .cursorrules files (parallel pattern)
- Aider AGENTS.md (alternative format)

---

## Word Count Target

- Total Chapter: 8,000-10,000 words
- Breakdown:
  - Sections 1-7 (Foundations): 3,000 words
  - Sections 8-11 (Implementation): 3,000 words
  - Sections 12-15 (Advanced): 2,000-4,000 words
  - Examples: 1,000-1,500 words
  - Exercises: 800-1,000 words (instructions, templates)

---

## Status: Draft

**Version**: 0.1
**Last Updated**: Jan 26, 2026
**Ready For**: Content creation and outline validation

### Next Steps Before Writing
1. Validate outline structure with technical reviewer
2. Confirm code examples align with latest Claude API behavior
3. Finalize diagrams (get designer specs)
4. Map section dependencies (ensure prerequisites clear)
5. Estimate time for reader to complete chapter + exercises

### Known Gaps / TBD
- [ ] Final code examples for each project type template
- [ ] Exact metrics/data for context dilution diagram
- [ ] Screenshot of real hierarchical CLAUDE.md structure
- [ ] Video walkthrough of Exercise 2 (design hierarchy)
- [ ] Template files readers can download
