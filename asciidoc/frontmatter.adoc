== The Meta-Engineer: 10x Was the Floor

=== Building Autonomous AI Systems with Claude Code

by James Phoenix

=== About This Book

What if you could mass-produce software? Not by hiring more engineers, but by building systems that compound your output.

This book teaches meta-engineering: the practice of orchestrating AI agents to build systems that build systems. Starting from zero, you’ll progress through Claude Code fundamentals, context engineering, verification patterns, and production harnesses. By the end, you’ll run autonomous agent loops that pick up tasks, write code, run tests, and commit, iterating through your backlog while you focus on architecture.

15 chapters. 54,000 words. Every concept backed by runnable TypeScript code. No theory without practice.

Written by an engineer who used the techniques in this book to write this book.

=== Who This Book Is For

* Software engineers transitioning to AI-assisted development
* Technical leads building AI-powered development workflows
* Anyone who wants to multiply their engineering output with Claude Code

=== Companion Repository

All code examples from this book are available on GitHub:

*https://github.com/Just-Understanding-Data-Ltd/compound-engineering-book*

The `examples/` folder contains runnable TypeScript code for every chapter. Clone the repo to follow along:

....
git clone https://github.com/Just-Understanding-Data-Ltd/compound-engineering-book.git
cd compound-engineering-book
npm install
....

Each chapter’s examples are in `examples/chXX/`. Run any example with:

....
npx tsx examples/ch04/agent.ts
....

=== How to Read This Book

* *Part I (Chapters 1-3)*: Foundations - Start here if you're new to Claude Code
* *Part II (Chapters 4-6)*: Core Techniques - Essential patterns for daily work
* *Part III (Chapters 7-9)*: Advanced Patterns - Deep dives for power users
* *Part IV (Chapters 10-16)*: Production Systems - Building autonomous systems

=== Chapter Guide

[cols="1,3",width="100%"]
|===
|Chapter |Summary

|*Part I: Foundations*
|

|1. The Compound Systems Engineer
|Meet the career archetype that treats engineering as portfolio management, building leverage that compounds rather than linear output.

|2. Getting Started with Claude Code
|Install the CLI, run your first conversation, and understand the complete tool ecosystem for AI-assisted development.

|3. Prompting Fundamentals
|Master chain-of-thought, constraint-based, and few-shot prompting patterns that form the foundation of effective agent communication.

|*Part II: Core Techniques*
|

|4. Writing Your First CLAUDE.md
|Configure Claude's behavior through project-specific instructions, hierarchical rules, and error documentation.

|5. The 12-Factor Agent
|Apply twelve production principles (structured outputs, tool selection, managed state) to build reliable LLM agents.

|6. The Verification Ladder
|Choose the right verification level (types, unit tests, property tests, formal specs) for each task using the verification sandwich pattern.

|*Part III: Advanced Patterns*
|

|7. Quality Gates That Compound
|Build automated gates (pre-commit hooks, CI reviews, type-driven development) that filter errors before they propagate.

|8. Error Handling & Debugging
|Apply the five-point diagnostic framework, encode errors into prevention, and recover from failed trajectories.

|9. Context Engineering Deep Dive
|Apply information theory to context windows: manage entropy, progressive disclosure, and context rot in long sessions.

|*Part IV: Production Systems*
|

|10. The RALPH Loop
|Implement fresh-context iteration: task queues, git-based memory, and overnight autonomous development.

|11. Sub-Agent Architecture
|Delegate to specialized agents, balance accuracy vs latency, and implement parallel swarm patterns.

|12. Development Workflows
|Use plan mode for strategic thinking, git worktrees for parallelism, and script capture for automation.

|13. Building the Harness
|Construct the four-layer architecture (Claude config, repo engineering, meta-engineering, closed-loop optimization).

|14. The Meta-Engineer Playbook
|Treat prompts as assets, manage skill atrophy, and navigate the six waves of AI-assisted coding.

|15. Model Strategy & Cost Optimization
|Switch between Haiku/Sonnet/Opus, implement cost protection layers, and measure AI spend ROI.

|16. Building Autonomous Systems
|Implement RALPH in practice: task scoring, adversarial review agents, custom skills, and memory architecture.
|===
