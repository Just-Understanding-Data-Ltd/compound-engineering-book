# Diagram Opportunities - 2026-01-27 (v3)

## Summary
- Files scanned: 15 chapters
- Existing diagrams: 21 files in `assets/diagrams/`
- Diagram opportunities identified: 18 (High: 10, Medium: 8)

## Current Coverage

| Chapter | Existing Diagrams | Coverage |
|---------|------------------|----------|
| ch01 | 4 (flywheel, pyramid, feedback-loop, portfolio) | Excellent |
| ch02 | 3 (agent-vs-chat, tool-ecosystem, two-mode) | Excellent |
| ch03 | 1 (prompt-anatomy) | Good |
| ch04 | 1 (claudemd-hierarchy) | Good |
| ch05 | 1 (12factor-overview) | Good |
| ch06 | 1 (verification-ladder) | Good |
| ch07 | 1 (quality-gates) | Needs More |
| ch08 | 1 (error-diagnostic) | Needs More |
| ch09 | 1 (context-window) | Needs More |
| ch10 | 1 (ralph-loop) | Good |
| ch11 | 1 (subagent-architecture) | Good |
| ch12 | 1 (workflows) | Needs More |
| ch13 | 1 (harness-architecture) | Needs More |
| ch14 | 1 (six-waves) | Needs More |
| ch15 | 1 (model-selection) | Needs More |

---

## Opportunities by Chapter

### ch03-prompting-fundamentals.md

#### Opportunity 1: RISEN Framework Visual
- **Location**: Lines 26-60
- **Type**: flowchart/component
- **Priority**: High
- **Description**: The RISEN framework (Role, Instructions, Situation, Examples, Next Steps) is a core teaching concept described in detail but only shown as text. A visual breakdown would reinforce learning.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph RISEN["RISEN Framework"]
        direction TB
        R["R: Role
Define AI persona and expertise"]
        I["I: Instructions
Specify desired actions and format"]
        S["S: Situation
Provide context and constraints"]
        E["E: Examples
Show desired output patterns"]
        N["N: Next Steps
Define success criteria"]

        R --> I --> S --> E --> N
    end

    subgraph Output["Result"]
        O["Focused, consistent responses
aligned to expectations"]
    end

    RISEN --> Output
```

**Suggested filename**: `assets/diagrams/ch03-risen-framework.md`

---

### ch07-quality-gates-that-compound.md

#### Opportunity 2: Quality Gate Pipeline Flow
- **Location**: Lines 80-150
- **Type**: flowchart/pipeline
- **Priority**: High
- **Description**: The chapter describes pre-commit hooks, post-edit hooks, and gate sequences but lacks a unified visual showing how gates flow together in the development pipeline.

**Draft Mermaid:**
```mermaid
flowchart LR
    subgraph PreEdit["Pre-Edit Gates"]
        P1["Lint check"]
        P2["Type check"]
        P3["Format check"]
    end

    subgraph Edit["AI Edit"]
        E["Claude makes changes"]
    end

    subgraph PostEdit["Post-Edit Gates"]
        Q1["Syntax valid?"]
        Q2["Types pass?"]
        Q3["Tests pass?"]
        Q4["No regressions?"]
    end

    subgraph Commit["Commit Gate"]
        C["Pre-commit hooks"]
    end

    PreEdit -->|"Pass"| Edit
    Edit --> PostEdit
    PostEdit -->|"All pass"| Commit
    PostEdit -->|"Fail"| Edit

    style PreEdit fill:#ffd06b
    style PostEdit fill:#6bff9f
    style Commit fill:#6bffff
```

**Suggested filename**: `assets/diagrams/ch07-gate-pipeline.md`

#### Opportunity 3: Speed Gates vs Depth Gates
- **Location**: Lines 200-280
- **Type**: comparison chart
- **Priority**: Medium
- **Description**: The chapter contrasts fast gates (syntax, lint) vs slow gates (integration tests, E2E). A visual comparison would clarify when to use each.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Speed["Speed Gates (< 5 sec)"]
        S1["Syntax check"]
        S2["Type check"]
        S3["Lint"]
        S4["Format"]
    end

    subgraph Depth["Depth Gates (> 30 sec)"]
        D1["Unit tests"]
        D2["Integration tests"]
        D3["E2E tests"]
        D4["Security scan"]
    end

    subgraph Usage["When to Use"]
        U1["Speed: Every edit
Run constantly"]
        U2["Depth: Before commit
Run periodically"]
    end

    Speed --> U1
    Depth --> U2

    style Speed fill:#6bffff
    style Depth fill:#ffd06b
```

**Suggested filename**: `assets/diagrams/ch07-gate-types.md`

---

### ch08-error-handling-and-debugging.md

#### Opportunity 4: Error Recovery Decision Tree
- **Location**: Lines 200-300
- **Type**: decision flowchart
- **Priority**: High
- **Description**: The chapter describes a systematic approach to diagnosing errors (syntax, runtime, logic, environment) but lacks a decision tree for practitioners to follow.

**Draft Mermaid:**
```mermaid
flowchart TB
    Start["Error Encountered"]

    Q1{"Does code compile?"}
    Q2{"Do types check?"}
    Q3{"Do tests pass?"}
    Q4{"Same behavior locally?"}

    A1["Syntax Error
Check brackets, imports"]
    A2["Type Error
Check interfaces, generics"]
    A3["Logic Error
Add test, debug incrementally"]
    A4["Environment Error
Check deps, config, paths"]

    Start --> Q1
    Q1 -->|"No"| A1
    Q1 -->|"Yes"| Q2
    Q2 -->|"No"| A2
    Q2 -->|"Yes"| Q3
    Q3 -->|"No"| A3
    Q3 -->|"Yes"| Q4
    Q4 -->|"No"| A4
    Q4 -->|"Yes"| A3

    style A1 fill:#ff6b6b
    style A2 fill:#ffa06b
    style A3 fill:#ffd06b
    style A4 fill:#d0ff6b
```

**Suggested filename**: `assets/diagrams/ch08-error-decision-tree.md`

---

### ch09-context-engineering-deep-dive.md

#### Opportunity 5: Backpressure Pattern
- **Location**: Lines 250-320
- **Type**: flowchart
- **Priority**: High
- **Description**: The backpressure pattern (suppress output on success, verbose on failure) is a key concept for context management but only described in prose.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Input["Operation Input"]
        I["Run command/test"]
    end

    subgraph Result{"Result?"}
        R["Check outcome"]
    end

    subgraph Success["On Success"]
        S1["Minimal output"]
        S2["'All tests passed'"]
        S3["Context preserved"]
    end

    subgraph Failure["On Failure"]
        F1["Full error output"]
        F2["Stack traces"]
        F3["Diagnostic info"]
    end

    Input --> Result
    Result -->|"Pass"| Success
    Result -->|"Fail"| Failure

    style Success fill:#6bff9f
    style Failure fill:#ff6b6b
```

**Suggested filename**: `assets/diagrams/ch09-backpressure-pattern.md`

#### Opportunity 6: Information Theory Model
- **Location**: Lines 50-120
- **Type**: conceptual diagram
- **Priority**: Medium
- **Description**: The chapter opens with Shannon's information theory applied to AI context (signal vs noise). A visual would reinforce the mental model.

**Draft Mermaid:**
```mermaid
flowchart LR
    subgraph Source["Source (You)"]
        S["Intent + Context"]
    end

    subgraph Channel["Noisy Channel"]
        C["Context Window
(limited capacity)"]
    end

    subgraph Receiver["Receiver (LLM)"]
        R["Interpretation"]
    end

    subgraph Output["Output"]
        O["Generated Code"]
    end

    S -->|"Signal"| C
    C -->|"Signal + Noise"| R
    R --> O

    N["Noise:
- Irrelevant files
- Old context
- Ambiguity"]

    N -.->|"Corrupts"| C

    style N fill:#ff6b6b
    style C fill:#ffd06b
```

**Suggested filename**: `assets/diagrams/ch09-information-theory.md`

---

### ch10-the-ralph-loop.md

#### Opportunity 7: Circuit Breaker State Machine
- **Location**: Lines 420-480
- **Type**: state diagram
- **Priority**: Medium
- **Description**: The circuit breaker pattern (open/closed/half-open states) is discussed but not visualized.

**Draft Mermaid:**
```mermaid
stateDiagram-v2
    [*] --> Closed

    Closed --> Open : 3 consecutive failures
    Closed --> Closed : Success (reset counter)

    Open --> HalfOpen : Timeout (5 min)
    Open --> Open : Reject requests

    HalfOpen --> Closed : Success
    HalfOpen --> Open : Failure

    note right of Closed
        Normal operation
        Tasks processed
    end note

    note right of Open
        Tripped
        All tasks rejected
        Human review needed
    end note

    note right of HalfOpen
        Testing recovery
        Single task allowed
    end note
```

**Suggested filename**: `assets/diagrams/ch10-circuit-breaker.md`

---

### ch11-sub-agent-architecture.md

#### Opportunity 8: Context Isolation Diagram
- **Location**: Lines 150-220
- **Type**: architecture diagram
- **Priority**: High
- **Description**: The chapter explains that sub-agents have isolated context from the parent agent. A visual showing the boundary and what crosses it would clarify this key concept.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Parent["Parent Agent Context"]
        PC["Full conversation history
CLAUDE.md loaded
All project knowledge"]
        PT["Task Assignment"]
    end

    subgraph Boundary["Context Boundary"]
        B["Only passes:
- Specific prompt
- Scoped files
- Tool subset"]
    end

    subgraph Child["Sub-Agent Context"]
        CC["Fresh context
Focused scope
Limited knowledge"]
        CR["Result"]
    end

    PT --> Boundary
    Boundary --> CC
    CR -->|"Summary only"| Parent

    style Boundary fill:#ffd06b
```

**Suggested filename**: `assets/diagrams/ch11-context-isolation.md`

---

### ch12-development-workflows.md

#### Opportunity 9: Plan Mode Two-Phase Pattern
- **Location**: Lines 12-28
- **Type**: flowchart
- **Priority**: High
- **Description**: The chapter shows an ASCII diagram of Plan Mode phases. A proper Mermaid diagram would be more readable.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Phase1["Phase 1: PLAN MODE"]
        direction TB
        P1["Understand requirements"]
        P2["Analyze architecture"]
        P3["Identify dependencies"]
        P4["Propose approaches"]
        P5["Validate with human"]
        P6["Exit plan mode"]

        P1 --> P2 --> P3 --> P4 --> P5 --> P6
    end

    subgraph Phase2["Phase 2: EXECUTION MODE"]
        direction TB
        E1["Follow the plan"]
        E2["Write code"]
        E3["Run tests"]
        E4["Fix issues"]
        E5["Done"]

        E1 --> E2 --> E3 --> E4 --> E5
    end

    Phase1 -->|"Shift+Tab"| Phase2

    style Phase1 fill:#6bffff
    style Phase2 fill:#6bff9f
```

**Suggested filename**: `assets/diagrams/ch12-plan-mode.md`

#### Opportunity 10: Git Worktrees Parallel Development
- **Location**: Lines 76-140
- **Type**: architecture diagram
- **Priority**: High
- **Description**: Git worktrees enabling parallel AI development is a key concept. The chapter describes it with ASCII but a visual would show the parallel nature better.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Repo["Shared Git Repository"]
        G[".git/
(commits, branches, history)"]
    end

    subgraph WT1["Worktree 1: Main"]
        W1["~/my-project/
Branch: main"]
        A1["Claude Session 1"]
    end

    subgraph WT2["Worktree 2: Auth"]
        W2["~/my-project-auth/
Branch: feature/auth"]
        A2["Claude Session 2"]
    end

    subgraph WT3["Worktree 3: API"]
        W3["~/my-project-api/
Branch: feature/api"]
        A3["Claude Session 3"]
    end

    Repo --- WT1
    Repo --- WT2
    Repo --- WT3

    W1 --> A1
    W2 --> A2
    W3 --> A3

    style Repo fill:#ffd06b
    style A1 fill:#6bff9f
    style A2 fill:#6bff9f
    style A3 fill:#6bff9f
```

**Suggested filename**: `assets/diagrams/ch12-git-worktrees.md`

#### Opportunity 11: Incremental Development Pattern
- **Location**: Lines 172-258
- **Type**: flowchart
- **Priority**: Medium
- **Description**: The incremental development pattern (small steps, validate each) is explained but a visual loop would reinforce the pattern.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Loop["Incremental Development Loop"]
        direction TB
        I1["Request smallest useful piece
(20-50 lines)"]
        I2["Run code immediately"]
        I3["Validate behavior"]
        I4{"Issues?"}
        I5["Fix before proceeding"]
        I6["Use working code as context
for next increment"]

        I1 --> I2 --> I3 --> I4
        I4 -->|"Yes"| I5 --> I3
        I4 -->|"No"| I6 --> I1
    end

    subgraph Contrast["vs Large Request"]
        L1["1000+ lines generated"]
        L2["65% chance of error"]
        L3["Error buried somewhere"]
    end

    style Loop fill:#6bff9f
    style Contrast fill:#ff6b6b
```

**Suggested filename**: `assets/diagrams/ch12-incremental-development.md`

---

### ch13-building-the-harness.md

#### Opportunity 12: Closed-Loop Optimization Cycle
- **Location**: Lines 291-340
- **Type**: cycle diagram
- **Priority**: High
- **Description**: The closed-loop optimization pattern (telemetry -> constraints -> agent fix -> verify) is central to Layer 4 but only described in prose and ASCII.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Loop["Closed-Loop Optimization"]
        T["Service Under Load"]
        M["Capture Telemetry
(memory, latency, errors)"]
        C["Evaluate Constraints"]
        V{"Violations?"}
        A["Agent Proposes Fix"]
        P["Apply Patch"]
        R["Re-test"]

        T --> M --> C --> V
        V -->|"Yes"| A --> P --> R --> M
        V -->|"No"| Done["Constraints Satisfied"]
    end

    subgraph Constraints["Example Constraints"]
        C1["memory_max_mb: 300"]
        C2["p99_latency_ms: 100"]
        C3["heap_growth_slope: 0"]
    end

    C --- Constraints

    style A fill:#6bff9f
    style Done fill:#6bffff
```

**Suggested filename**: `assets/diagrams/ch13-closed-loop.md`

---

### ch14-the-meta-engineer-playbook.md

#### Opportunity 13: Skill Atrophy Ladder
- **Location**: Lines 225-301
- **Type**: vertical hierarchy
- **Priority**: High
- **Description**: The skill atrophy framework (what to keep sharp vs let atrophy) is a key career insight that deserves visualization.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Keep["KEEP SHARP"]
        K1["Understanding the problem"]
        K2["Designing the solution"]
        K3["Verification & correctness"]
    end

    subgraph OK["OK TO DELEGATE"]
        O1["Implementation patterns"]
    end

    subgraph Forget["OK TO FORGET"]
        F1["Syntax & API recall"]
    end

    subgraph Good["GOOD RIDDANCE"]
        G1["Boilerplate"]
    end

    Keep --> OK --> Forget --> Good

    style Keep fill:#ff6b6b
    style OK fill:#ffd06b
    style Forget fill:#6bff9f
    style Good fill:#6bffff
```

**Suggested filename**: `assets/diagrams/ch14-skill-atrophy.md`

#### Opportunity 14: Four Levels of Automation
- **Location**: Lines 434-471
- **Type**: progression diagram
- **Priority**: Medium
- **Description**: The four levels (Manual -> AI-Assisted -> Building Tools -> Meta-Infrastructure) show career progression but are only in prose.

**Draft Mermaid:**
```mermaid
flowchart LR
    subgraph L0["Level 0"]
        M["Manual Coding
1x productivity"]
    end

    subgraph L1["Level 1"]
        A["AI-Assisted
5-10x productivity"]
    end

    subgraph L2["Level 2"]
        T["Building Tools with AI
20-50x productivity"]
    end

    subgraph L3["Level 3"]
        I["Meta-Infrastructure
100-500x productivity"]
    end

    L0 -->|"Add AI"| L1
    L1 -->|"Build tools"| L2
    L2 -->|"Tools build tools"| L3

    style L0 fill:#ff6b6b
    style L1 fill:#ffd06b
    style L2 fill:#6bff9f
    style L3 fill:#6bffff
```

**Suggested filename**: `assets/diagrams/ch14-automation-levels.md`

---

### ch15-model-strategy-and-cost-optimization.md

#### Opportunity 15: Progressive Model Escalation
- **Location**: Lines 169-209
- **Type**: flowchart
- **Priority**: High
- **Description**: The escalation pattern (start cheap, escalate on quality gate failure) is a key cost optimization strategy.

**Draft Mermaid:**
```mermaid
flowchart TB
    Start["New Task"]

    H["Try Haiku"]
    HQ{"Quality gates pass?"}

    S["Escalate to Sonnet"]
    SQ{"Quality gates pass?"}

    O["Escalate to Opus"]

    Done["Return result"]

    Start --> H --> HQ
    HQ -->|"Yes"| Done
    HQ -->|"No"| S --> SQ
    SQ -->|"Yes"| Done
    SQ -->|"No"| O --> Done

    Cost1["Cost: $0.01"]
    Cost2["Cost: $0.05"]
    Cost3["Cost: $0.25"]

    H --- Cost1
    S --- Cost2
    O --- Cost3

    style H fill:#6bffff
    style S fill:#ffd06b
    style O fill:#ff6b6b
```

**Suggested filename**: `assets/diagrams/ch15-model-escalation.md`

#### Opportunity 16: Multi-Layer Timeout Protection
- **Location**: Lines 238-350
- **Type**: stack diagram
- **Priority**: Medium
- **Description**: The four layers of cost protection (job timeout, request token cap, input size limit, budget alerts) form a defense-in-depth strategy.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Layer4["Layer 4: Budget Alerts"]
        B["Daily/Monthly limits
Alert at 80%"]
    end

    subgraph Layer3["Layer 3: Input Size Limits"]
        I["Max files: 50
Max lines/file: 500
Max tokens: 50K"]
    end

    subgraph Layer2["Layer 2: Request Token Caps"]
        R["max_tokens: 4096
Input truncation"]
    end

    subgraph Layer1["Layer 1: Job Timeouts"]
        J["Job: 15 min
Step: 10 min"]
    end

    subgraph Core["AI Request"]
        C["API Call"]
    end

    Layer4 --> Layer3 --> Layer2 --> Layer1 --> Core

    style Layer4 fill:#ff6b6b
    style Layer3 fill:#ffa06b
    style Layer2 fill:#ffd06b
    style Layer1 fill:#d0ff6b
```

**Suggested filename**: `assets/diagrams/ch15-timeout-layers.md`

#### Opportunity 17: Three-Tier Model Hierarchy
- **Location**: Lines 46-112
- **Type**: comparison diagram
- **Priority**: Medium
- **Description**: The Haiku/Sonnet/Opus hierarchy with use cases could be a quick reference visual.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph Haiku["Tier 1: Haiku"]
        H1["Cost: $0.25/$1.25 per MTok"]
        H2["Latency: 1-2 sec"]
        H3["Use: File reads, searches,
simple edits, annotations"]
        H4["60-80% of tasks"]
    end

    subgraph Sonnet["Tier 2: Sonnet"]
        S1["Cost: $3/$15 per MTok"]
        S2["Latency: 2-4 sec"]
        S3["Use: Features, refactoring,
tests, bug fixes"]
        S4["Most development"]
    end

    subgraph Opus["Tier 3: Opus"]
        O1["Cost: $15/$75 per MTok"]
        O2["Latency: 4-8 sec"]
        O3["Use: Architecture, security,
large refactors, complex debug"]
        O4["5-10% of tasks"]
    end

    Haiku --> Sonnet --> Opus

    style Haiku fill:#6bffff
    style Sonnet fill:#ffd06b
    style Opus fill:#ff6b6b
```

**Suggested filename**: `assets/diagrams/ch15-model-tiers.md`

#### Opportunity 18: YOLO Mode Safety Hierarchy
- **Location**: Lines 432-530
- **Type**: hierarchy diagram
- **Priority**: Medium
- **Description**: The four safety levels (prompts -> YOLO+Git -> YOLO+Git+Gates -> YOLO+Git+Gates+Review) show a progression.

**Draft Mermaid:**
```mermaid
flowchart TB
    subgraph L1["Level 1: Permission Prompts"]
        P1["Safety: High"]
        P2["Productivity: Very Low"]
        P3["Use: Untrusted environments"]
    end

    subgraph L2["Level 2: YOLO + Git"]
        Y1["Safety: Medium"]
        Y2["Productivity: High"]
        Y3["Use: Personal experiments"]
    end

    subgraph L3["Level 3: YOLO + Git + Gates"]
        G1["Safety: High"]
        G2["Productivity: Very High"]
        G3["Use: Daily development"]
    end

    subgraph L4["Level 4: + Manual Review"]
        R1["Safety: Very High"]
        R2["Productivity: High"]
        R3["Use: Critical systems"]
    end

    L1 --> L2 --> L3 --> L4

    Rec["Recommended: Level 3"]
    L3 --- Rec

    style L3 fill:#6bff9f
    style Rec fill:#6bffff
```

**Suggested filename**: `assets/diagrams/ch15-yolo-safety.md`

---

## Priority Summary

### High Priority (10)
1. ch03: RISEN Framework Visual
2. ch07: Quality Gate Pipeline Flow
3. ch08: Error Recovery Decision Tree
4. ch09: Backpressure Pattern
5. ch11: Context Isolation Diagram
6. ch12: Plan Mode Two-Phase Pattern
7. ch12: Git Worktrees Parallel Development
8. ch13: Closed-Loop Optimization Cycle
9. ch14: Skill Atrophy Ladder
10. ch15: Progressive Model Escalation

### Medium Priority (8)
1. ch07: Speed Gates vs Depth Gates
2. ch09: Information Theory Model
3. ch10: Circuit Breaker State Machine
4. ch12: Incremental Development Pattern
5. ch14: Four Levels of Automation
6. ch15: Multi-Layer Timeout Protection
7. ch15: Three-Tier Model Hierarchy
8. ch15: YOLO Mode Safety Hierarchy

---

## Recommendations

1. **Chapters needing most attention**: ch07, ch12, ch14, ch15 each have multiple opportunities
2. **Quick wins**: ch03 RISEN and ch14 Skill Atrophy are high-value, straightforward diagrams
3. **Consider merging**: ch15 has 4 opportunities that could potentially be combined into 2 comprehensive diagrams
